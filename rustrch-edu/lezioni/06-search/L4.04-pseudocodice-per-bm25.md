## Teoria

L'algoritmo BM25 (Best Match 25) è uno dei metodi più utilizzati per il ranking dei documenti nei motori di ricerca basati su keyword. Questo algoritmo è una versione migliorata del classico modello TF-IDF (Term Frequency-Inverse Document Frequency) e introduce due parametri fondamentali: k1 e b. Questi parametri permettono di regolare il comportamento dell'algoritmo in base alle caratteristiche dei documenti e delle query.

Il parametro k1 controlla l'effetto della saturazione della frequenza dei termini. In altre parole, regola quanto la frequenza di un termine in un documento influenzi il punteggio finale. Un valore basso di k1 significa che la frequenza del termine ha un impatto minore sul punteggio, mentre un valore alto aumenta l'importanza della frequenza. Tipicamente, k1 assume valori compresi tra 1.2 e 2.0.

Il parametro b, invece, controlla l'effetto della lunghezza del documento. Un valore di b pari a 1 significa che la lunghezza del documento ha un impatto massimo sul punteggio, mentre un valore di 0 significa che la lunghezza non ha alcun effetto. In pratica, b viene spesso impostato a valori compresi tra 0.5 e 0.8, a seconda del tipo di documenti che si stanno indicizzando.

L'algoritmo BM25 calcola il punteggio di rilevanza di un documento rispetto a una query utilizzando la seguente formula:

```
score(D, Q) = Σ (IDF(q_i) * (f(q_i, D) * (k1 + 1)) / (f(q_i, D) + k1 * (1 - b + b * (|D| / avgdl))))
```

Dove:
- D è il documento
- Q è la query
- q_i è un termine della query
- f(q_i, D) è la frequenza del termine q_i nel documento D
- |D| è la lunghezza del documento D
- avgdl è la lunghezza media dei documenti nella collezione
- IDF(q_i) è il peso inverso della frequenza del documento per il termine q_i

## Esempio

Supponiamo di avere una collezione di documenti che parlano di programmazione in Rust. Un utente inserisce la query "come implementare un motore di ricerca in Rust". Utilizzando BM25, vogliamo calcolare il punteggio di rilevanza per ogni documento nella nostra collezione.

Per prima cosa, dobbiamo calcolare l'IDF per ogni termine della query. L'IDF di un termine è calcolato come:

```
IDF(q_i) = log((N - n(q_i) + 0.5) / (n(q_i) + 0.5))
```

Dove N è il numero totale di documenti nella collezione e n(q_i) è il numero di documenti che contengono il termine q_i.

Successivamente, per ogni documento, calcoliamo il punteggio BM25 utilizzando la formula sopra menzionata. Supponiamo di avere un documento che contiene le parole "motore", "ricerca", "Rust" e "implementare". La frequenza di questi termini nel documento influenzerà il punteggio finale, così come la lunghezza del documento rispetto alla lunghezza media dei documenti nella collezione.

## Pseudocodice

```rust
// Struttura per rappresentare un documento
struct Document {
    id: u32,
    content: String,
    length: usize, // Lunghezza del documento in termini di numero di parole
}

// Struttura per rappresentare una query
struct Query {
    terms: Vec<String>, // Termini della query
}

// Funzione per calcolare l'IDF di un termine
fn calculate_idf(term: &str, total_documents: usize, documents_with_term: usize) -> f32 {
    // Calcola l'IDF utilizzando la formula standard
    let numerator = (total_documents - documents_with_term + 0.5) as f32;
    let denominator = (documents_with_term + 0.5) as f32;
    numerator.ln() / denominator.ln()
}

// Funzione per calcolare il punteggio BM25 per un documento rispetto a una query
fn calculate_bm25_score(
    document: &Document,
    query: &Query,
    k1: f32,
    b: f32,
    avg_document_length: f32,
    idf_scores: &std::collections::HashMap<String, f32>,
) -> f32 {
    let mut score = 0.0;
    
    for term in &query.terms {
        // Ottieni la frequenza del termine nel documento
        let term_frequency = count_term_frequency(&document.content, term);
        
        // Ottieni l'IDF del termine
        let idf = idf_scores.get(term).unwrap_or(&0.0);
        
        // Calcola il punteggio BM25 per il termine
        let numerator = term_frequency as f32 * (k1 + 1.0);
        let denominator = term_frequency as f32 + k1 * (1.0 - b + b * (document.length as f32 / avg_document_length));
        
        score += idf * (numerator / denominator);
    }
    
    score
}

// Funzione ausiliaria per contare la frequenza di un termine in un documento
fn count_term_frequency(document_content: &str, term: &str) -> usize {
    // Implementazione semplificata: conta quante volte il termine appare nel documento
    document_content.split_whitespace().filter(|&word| word == term).count()
}

// Funzione principale per calcolare i punteggi BM25 per tutti i documenti
fn bm25_scoring(
    documents: &[Document],
    query: &Query,
    k1: f32,
    b: f32,
) -> Vec<(u32, f32)> {
    let total_documents = documents.len();
    let avg_document_length = documents.iter().map(|d| d.length).sum::<usize>() as f32 / total_documents as f32;
    
    // Calcola l'IDF per ogni termine della query
    let mut idf_scores = std::collections::HashMap::new();
    for term in &query.terms {
        let documents_with_term = documents.iter().filter(|d| d.content.contains(term)).count();
        let idf = calculate_idf(term, total_documents, documents_with_term);
        idf_scores.insert(term.clone(), idf);
    }
    
    // Calcola il punteggio BM25 per ogni documento
    let mut results = Vec::new();
    for document in documents {
        let score = calculate_bm25_score(document, query, k1, b, avg_document_length, &idf_scores);
        results.push((document.id, score));
    }
    
    // Ordina i risultati in base al punteggio
    results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    
    results
}
```

## Risorse

1. [Documentazione ufficiale di BM25 su Wikipedia](https://en.wikipedia.org/wiki/Okapi_BM25)
2. [The Rust Book - Capitolo su Algoritmi](https://doc.rust-lang.org/book/ch00-00-introduction.html)
3. [Introduzione a TF-IDF e BM25](https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html)

## Esercizio

Immagina di dover implementare una funzione che calcoli il punteggio BM25 per una collezione di documenti. Quali considerazioni dovresti fare per scegliere i valori dei parametri k1 e b? Scrivi una breve spiegazione e un esempio di come potresti determinare questi valori in base alle caratteristiche dei tuoi documenti.