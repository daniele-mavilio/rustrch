## Teoria

L'ottimizzazione delle performance è un aspetto cruciale nello sviluppo di un motore di ricerca efficiente. In questa sezione, esploreremo le tecniche di caching e ottimizzazione delle query, fondamentali per migliorare la velocità di risposta e ridurre il carico computazionale. Il caching consente di memorizzare i risultati di operazioni costose, come le query di ricerca, in modo da poterle riutilizzare senza doverle ricalcolare ogni volta. Questo è particolarmente utile in scenari in cui le stesse query vengono eseguite ripetutamente.

Un'altra tecnica importante è l'ottimizzazione delle query, che mira a ridurre il tempo necessario per eseguire una ricerca. Questo può essere ottenuto attraverso l'uso di indici efficienti, la riduzione del numero di operazioni di I/O, e l'implementazione di algoritmi di ricerca più veloci. Ad esempio, l'uso di strutture dati come gli alberi B o gli hash map può migliorare significativamente le prestazioni delle query.

## Esempio

Immaginiamo di avere un motore di ricerca che deve gestire migliaia di query al secondo. Senza caching, ogni query richiederebbe l'accesso al database e l'esecuzione di operazioni di ricerca costose. Con il caching, possiamo memorizzare i risultati delle query più frequenti in una cache in memoria, riducendo così il tempo di risposta e il carico sul database.

Ad esempio, se un utente cerca "Rust programming", il motore di ricerca può memorizzare i risultati di questa query in una cache. Quando un altro utente esegue la stessa query, il motore di ricerca può restituire i risultati dalla cache invece di ricalcolarli, migliorando così le prestazioni.

## Pseudocodice

```rust
// Definizione di una struttura per il caching
struct Cache {
    data: HashMap<String, Vec<Document>>, // Mappa delle query ai risultati
    max_size: usize, // Dimensione massima della cache
}

impl Cache {
    // Funzione per aggiungere una query e i suoi risultati alla cache
    fn insert(&mut self, query: String, results: Vec<Document>) {
        if self.data.len() >= self.max_size {
            // Rimuovi la query meno recentemente utilizzata se la cache è piena
            self.data.remove(&self.data.keys().next().unwrap());
        }
        self.data.insert(query, results);
    }

    // Funzione per recuperare i risultati di una query dalla cache
    fn get(&self, query: &str) -> Option<&Vec<Document>> {
        self.data.get(query)
    }
}

// Funzione per ottimizzare una query
fn optimize_query(query: &str) -> String {
    // Rimuovi parole comuni (stop words)
    let stop_words = ["il", "un", "e", "di", "a", "in"];
    let mut optimized_query = String::new();
    
    for word in query.split_whitespace() {
        if !stop_words.contains(&word) {
            optimized_query.push_str(word);
            optimized_query.push(' ');
        }
    }
    
    optimized_query.trim().to_string()
}

// Funzione per eseguire una query con caching
fn execute_query_with_cache(cache: &mut Cache, query: &str) -> Vec<Document> {
    let optimized_query = optimize_query(query);
    
    if let Some(results) = cache.get(&optimized_query) {
        // Restituisci i risultati dalla cache
        results.clone()
    } else {
        // Esegui la query e memorizza i risultati nella cache
        let results = execute_query(&optimized_query);
        cache.insert(optimized_query, results.clone());
        results
    }
}
```

## Risorse

1. [Documentazione ufficiale di Rust su HashMap](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
2. [Guida all'ottimizzazione delle query in Rust](https://doc.rust-lang.org/book/ch12-00-an-io-project.html)
3. [Tecniche di caching in Rust](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)

## Esercizio

Implementa una funzione di caching che memorizzi i risultati delle query di ricerca e li riutilizzi quando la stessa query viene eseguita nuovamente. Assicurati di gestire la dimensione massima della cache e di rimuovere le query meno recentemente utilizzate quando la cache è piena.

Traccia di soluzione:
1. Definisci una struttura `Cache` con un campo `data` di tipo `HashMap<String, Vec<Document>>` e un campo `max_size` di tipo `usize`.
2. Implementa un metodo `insert` per aggiungere una query e i suoi risultati alla cache.
3. Implementa un metodo `get` per recuperare i risultati di una query dalla cache.
4. Implementa una funzione `execute_query_with_cache` che utilizzi la cache per memorizzare e recuperare i risultati delle query.