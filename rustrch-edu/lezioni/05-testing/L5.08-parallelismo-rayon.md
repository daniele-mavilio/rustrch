## Teoria

Il parallelismo è una tecnica fondamentale per migliorare le prestazioni delle applicazioni, soprattutto quando si tratta di elaborare grandi quantità di dati. In Rust, la libreria Rayon offre un modo semplice ed efficiente per parallelizzare operazioni comuni, come l'elaborazione di collezioni di dati. Rayon è una libreria di parallelismo dati che consente di eseguire operazioni su collezioni in modo parallelo, sfruttando al meglio le risorse della CPU.

Rayon si basa sul concetto di "work-stealing", dove i thread che hanno completato i loro compiti possono "rubare" lavoro da altri thread che sono ancora occupati. Questo approccio garantisce un utilizzo equilibrato delle risorse e riduce i tempi di inattività dei thread. Inoltre, Rayon è progettato per essere sicuro e facile da usare, integrandosi perfettamente con il sistema di ownership e borrowing di Rust.

Uno dei principali vantaggi di Rayon è la sua semplicità. Con poche modifiche al codice, è possibile trasformare operazioni sequenziali in operazioni parallele. Ad esempio, invece di usare il metodo `iter()` per iterare su una collezione, si può usare `par_iter()` per eseguire l'iterazione in parallelo. Questo rende Rayon particolarmente adatto per task come il processing di dati, la ricerca e la manipolazione di collezioni.

## Esempio

Immaginiamo di avere un motore di ricerca che deve elaborare una grande quantità di documenti per costruire un indice invertito. Senza parallelismo, l'elaborazione di ogni documento avviene in modo sequenziale, il che può essere molto lento se il numero di documenti è elevato. Utilizzando Rayon, possiamo parallelizzare questo processo, dividendo il lavoro tra più thread.

Ad esempio, supponiamo di avere una lista di documenti e di voler calcolare la frequenza di ogni termine in ciascun documento. Senza parallelismo, il codice potrebbe apparire così:

```rust
let documents = vec!["document1", "document2", "document3"];
let term_frequencies: Vec<_> = documents.iter()
    .map(|doc| compute_term_frequency(doc))
    .collect();
```

Utilizzando Rayon, possiamo parallelizzare questa operazione:

```rust
use rayon::prelude::*;

let documents = vec!["document1", "document2", "document3"];
let term_frequencies: Vec<_> = documents.par_iter()
    .map(|doc| compute_term_frequency(doc))
    .collect();
```

In questo esempio, `par_iter()` divide la lista di documenti in più parti e elabora ogni parte in parallelo, riducendo significativamente il tempo totale di elaborazione.

## Pseudocodice

Ecco uno pseudocodice che illustra come utilizzare Rayon per parallelizzare l'elaborazione di documenti in un motore di ricerca:

```rust
// Importa la libreria Rayon
use rayon::prelude::*;

// Funzione per elaborare un singolo documento
fn process_document(document: &str) -> DocumentResult {
    // Elabora il documento e restituisci il risultato
    // Ad esempio, calcola la frequenza dei termini
    let mut result = DocumentResult::new();
    for term in document.split_whitespace() {
        *result.entry(term).or_insert(0) += 1;
    }
    result
}

// Funzione principale per elaborare tutti i documenti in parallelo
fn process_documents_parallel(documents: &[String]) -> Vec<DocumentResult> {
    // Utilizza par_iter() per elaborare i documenti in parallelo
    documents.par_iter()
        .map(|doc| process_document(doc))
        .collect()
}

// Esempio di utilizzo
fn main() {
    let documents = vec![
        "document1 content".to_string(),
        "document2 content".to_string(),
        "document3 content".to_string(),
    ];
    
    let results = process_documents_parallel(&documents);
    
    // Stampa i risultati
    for result in results {
        println!("{:?}", result);
    }
}
```

## Risorse

- [Documentazione ufficiale di Rayon](https://docs.rs/rayon/latest/rayon/)
- [The Rust Book - Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Rayon GitHub Repository](https://github.com/rayon-rs/rayon)

## Esercizio

1. **Domanda**: Qual è il principale vantaggio dell'utilizzo di Rayon rispetto all'implementazione manuale del parallelismo in Rust?
   - **Traccia di soluzione**: Rayon offre un'interfaccia semplice e sicura per parallelizzare operazioni comuni, riducendo la complessità del codice e migliorando le prestazioni.

2. **Esercizio pratico**: Scrivi uno pseudocodice che utilizza Rayon per parallelizzare il calcolo della somma di una lista di numeri.
   - **Traccia di soluzione**: Utilizza `par_iter()` per iterare sulla lista in parallelo e sommare i numeri.

```rust
use rayon::prelude::*;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let sum: i32 = numbers.par_iter().sum();
    println!("La somma è: {}", sum);
}
```