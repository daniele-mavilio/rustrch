# L5.06: Benchmarking

## Teoria

Il benchmarking è una pratica fondamentale nello sviluppo software, specialmente quando si lavora con linguaggi di sistema come Rust. Consiste nel misurare le prestazioni di un programma o di una sua parte per identificare colli di bottiglia e ottimizzare il codice. In Rust, il benchmarking è particolarmente importante perché il linguaggio è spesso scelto per applicazioni ad alte prestazioni, come motori di ricerca, dove ogni millisecondo conta.

Il benchmarking non è solo una questione di velocità. Include anche la misurazione dell'uso della memoria, del consumo della CPU e di altre risorse di sistema. Ad esempio, in un motore di ricerca, potrebbe essere importante misurare non solo quanto velocemente viene eseguita una query, ma anche quanta memoria viene utilizzata per mantenere l'indice di ricerca in memoria.

Uno degli strumenti più popolari per il benchmarking in Rust è Criterion. Criterion è una libreria che fornisce un modo semplice e potente per scrivere benchmark. Offre funzionalità come il rilevamento automatico delle regressioni delle prestazioni, la generazione di report dettagliati e la possibilità di confrontare le prestazioni tra diverse versioni del codice.

## Esempio

Immaginiamo di avere un motore di ricerca che deve elaborare un gran numero di documenti. Supponiamo di avere due implementazioni diverse per la tokenizzazione dei documenti: una che utilizza una semplice iterazione su stringhe e un'altra che utilizza espressioni regolari. Per decidere quale implementazione utilizzare, possiamo scrivere un benchmark che misura il tempo impiegato da entrambe le implementazioni per elaborare un gran numero di documenti.

Utilizzando Criterion, possiamo definire un benchmark che esegue entrambe le implementazioni più volte e misura il tempo medio di esecuzione. Questo ci permetterà di vedere quale implementazione è più veloce e di quantificare il miglioramento delle prestazioni.

Ad esempio, se la tokenizzazione con espressioni regolari è il 20% più veloce, potremmo decidere di utilizzare quella implementazione, anche se potrebbe essere più complessa da mantenere. Al contrario, se la differenza di prestazioni è minima, potremmo preferire l'implementazione più semplice e leggibile.

## Pseudocodice

```rust
// Definizione di un benchmark per la tokenizzazione
use criterion::{black_box, criterion_group, criterion_main, Criterion};

// Funzione di tokenizzazione semplice
fn tokenize_simple(text: &str) -> Vec<&str> {
    text.split_whitespace().collect()
}

// Funzione di tokenizzazione con espressioni regolari
fn tokenize_regex(text: &str) -> Vec<&str> {
    use regex::Regex;
    let re = Regex::new(r"\w+").unwrap();
    re.find_iter(text).map(|m| m.as_str()).collect()
}

// Benchmark per confrontare le due implementazioni
fn benchmark_tokenization(c: &mut Criterion) {
    let text = "Questo è un esempio di testo da tokenizzare";
    
    c.bench_function("tokenize_simple", |b| {
        b.iter(|| tokenize_simple(black_box(text)))
    });
    
    c.bench_function("tokenize_regex", |b| {
        b.iter(|| tokenize_regex(black_box(text)))
    });
}

// Configurazione del gruppo di benchmark
criterion_group!(benches, benchmark_tokenization);

// Punto di ingresso per l'esecuzione dei benchmark
criterion_main!(benches);
```

## Risorse

- [Documentazione ufficiale di Criterion](https://docs.rs/criterion/latest/criterion/)
- [The Rust Book - Benchmarking](https://doc.rust-lang.org/book/ch11-02-running-tests.html#benchmark-tests)
- [Rust by Example - Benchmarking](https://doc.rust-lang.org/rust-by-example/testing/benchmark.html)

## Esercizio

Scrivi un benchmark per confrontare due implementazioni diverse di una funzione che calcola la somma di un vettore di numeri interi. Una implementazione utilizza un ciclo `for`, mentre l'altra utilizza il metodo `iter().sum()`. Misura il tempo di esecuzione di entrambe le implementazioni e confronta i risultati.

Traccia di soluzione:
1. Crea un nuovo progetto Rust e aggiungi Criterion come dipendenza.
2. Definisci due funzioni: una che utilizza un ciclo `for` e un'altra che utilizza `iter().sum()`.
3. Scrivi un benchmark che confronta le due funzioni utilizzando Criterion.
4. Esegui il benchmark e analizza i risultati.
