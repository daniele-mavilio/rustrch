## Teoria

Gli esercizi e le domande di comprensione sono fondamentali per consolidare le conoscenze acquisite durante lo studio. In questa sezione, ci concentreremo su esercizi pratici e domande teoriche che coprono i concetti principali del testing in Rust, con particolare attenzione al benchmarking e al parallelismo. Questi esercizi sono progettati per aiutare a comprendere meglio come applicare i concetti teorici in scenari reali.

Il benchmarking è una tecnica essenziale per valutare le prestazioni del codice. In Rust, la libreria `criterion` è uno strumento potente per misurare e confrontare le prestazioni di diverse implementazioni. Attraverso esercizi pratici, è possibile imparare a identificare i colli di bottiglia e a ottimizzare il codice per migliorare l'efficienza.

Il parallelismo, d'altra parte, è cruciale per sfruttare appieno le risorse hardware moderne. La libreria `Rayon` offre un modo semplice ed efficiente per parallelizzare operazioni comuni, come l'elaborazione di collezioni di dati. Gli esercizi su Rayon aiutano a comprendere come trasformare operazioni sequenziali in operazioni parallele, migliorando così le prestazioni del codice.

## Esempio

Supponiamo di avere un motore di ricerca che deve elaborare una grande quantità di documenti per costruire un indice invertito. Senza parallelismo, l'elaborazione di ogni documento avviene in modo sequenziale, il che può essere molto lento se il numero di documenti è elevato. Utilizzando Rayon, possiamo parallelizzare questo processo, dividendo il lavoro tra più thread.

Ad esempio, supponiamo di avere una lista di URL da cui scaricare i documenti e di voler elaborare ogni documento per estrarne i termini. Senza parallelismo, il codice potrebbe apparire così:

```rust
let urls = vec!["url1", "url2", "url3"];
let documents: Vec<_> = urls.iter()
    .map(|url| download_and_process(url))
    .collect();
```

Utilizzando Rayon, possiamo parallelizzare questa operazione:

```rust
use rayon::prelude::*;

let urls = vec!["url1", "url2", "url3"];
let documents: Vec<_> = urls.par_iter()
    .map(|url| download_and_process(url))
    .collect();
```

In questo esempio, `par_iter()` divide la lista di URL in più parti e elabora ogni parte in parallelo, riducendo significativamente il tempo totale di elaborazione.

## Pseudocodice

Ecco uno pseudocodice che illustra come utilizzare Rayon per parallelizzare il crawling di documenti in un motore di ricerca:

```rust
// Importa la libreria Rayon
use rayon::prelude::*;

// Funzione per scaricare e elaborare un singolo documento
fn download_and_process(url: &str) -> Document {
    // Scarica il documento dall'URL
    let content = download_url(url);
    
    // Elabora il documento e restituisci il risultato
    let mut document = Document::new();
    for term in content.split_whitespace() {
        *document.entry(term).or_insert(0) += 1;
    }
    document
}

// Funzione principale per elaborare tutti gli URL in parallelo
fn crawl_urls_parallel(urls: &[String]) -> Vec<Document> {
    // Utilizza par_iter() per elaborare gli URL in parallelo
    urls.par_iter()
        .map(|url| download_and_process(url))
        .collect()
}

// Esempio di utilizzo
fn main() {
    let urls = vec![
        "https://example.com/doc1".to_string(),
        "https://example.com/doc2".to_string(),
        "https://example.com/doc3".to_string(),
    ];
    
    let documents = crawl_urls_parallel(&urls);
    
    // Stampa i documenti elaborati
    for doc in documents {
        println!("{:?}", doc);
    }
}
```

## Risorse

- [Documentazione ufficiale di Rayon](https://docs.rs/rayon/latest/rayon/)
- [The Rust Book - Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Rayon GitHub Repository](https://github.com/rayon-rs/rayon)

## Esercizio

1. **Domanda**: Qual è il principale vantaggio dell'utilizzo di Rayon rispetto all'implementazione manuale del parallelismo in Rust?
   - **Traccia di soluzione**: Rayon offre un'interfaccia semplice e sicura per parallelizzare operazioni comuni, riducendo la complessità del codice e migliorando le prestazioni.

2. **Esercizio pratico**: Scrivi uno pseudocodice che utilizza Rayon per parallelizzare il crawling di una lista di URL e il calcolo della frequenza dei termini.
   - **Traccia di soluzione**: Utilizza `par_iter()` per iterare sulla lista di URL in parallelo, scaricare i documenti e calcolare la frequenza dei termini.

```rust
use rayon::prelude::*;

fn main() {
    let urls = vec![
        "https://example.com/doc1".to_string(),
        "https://example.com/doc2".to_string(),
        "https://example.com/doc3".to_string(),
    ];
    
    let term_frequencies: Vec<_> = urls.par_iter()
        .map(|url| {
            let content = download_url(url);
            let mut freq = HashMap::new();
            for term in content.split_whitespace() {
                *freq.entry(term).or_insert(0) += 1;
            }
            freq
        })
        .collect();
    
    println!("{:?}", term_frequencies);
}
```

3. **Domanda**: Come si può misurare l'efficacia di un algoritmo di benchmarking in Rust?
   - **Traccia di soluzione**: L'efficacia di un algoritmo di benchmarking può essere misurata confrontando i tempi di esecuzione di diverse implementazioni e identificando i colli di bottiglia.

4. **Esercizio pratico**: Scrivi uno pseudocodice che utilizza Criterion per misurare le prestazioni di una funzione di ricerca in un motore di ricerca.
   - **Traccia di soluzione**: Utilizza Criterion per definire un benchmark che misura il tempo di esecuzione della funzione di ricerca e confronta diverse implementazioni.

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_search(c: &mut Criterion) {
    let documents = vec!["doc1", "doc2", "doc3"];
    c.bench_function("search", |b| b.iter(|| {
        let query = "search term";
        let results = search_documents(&documents, query);
        black_box(results);
    }));
}

criterion_group!(benches, benchmark_search);
criterion_main!(benches);
```

5. **Domanda**: Quali sono i principali vantaggi dell'utilizzo del parallelismo in un motore di ricerca?
   - **Traccia di soluzione**: Il parallelismo consente di elaborare grandi quantità di dati in modo più efficiente, riducendo i tempi di elaborazione e migliorando le prestazioni complessive del motore di ricerca.