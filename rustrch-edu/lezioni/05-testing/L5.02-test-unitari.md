## Teoria

I test unitari sono una parte fondamentale dello sviluppo software, poiché permettono di verificare che singole unità di codice funzionino correttamente in isolamento. In Rust, i test unitari sono scritti all'interno dello stesso file del codice che si vuole testare, utilizzando l'attributo `#[test]`. Questo attributo segnala al compilatore che la funzione è un test e deve essere eseguita come tale. 

In Rust, i test unitari sono solitamente collocati in un modulo `tests` all'interno dello stesso file del codice sorgente. Questo modulo è annotato con `#[cfg(test)]`, che indica che il modulo deve essere compilato e eseguito solo quando si eseguono i test. Questo approccio consente di mantenere i test vicini al codice che stanno testando, facilitando la manutenzione e la comprensione del codice.

Un test unitario in Rust è una funzione che non prende argomenti e non restituisce alcun valore. Tuttavia, se si verifica un errore durante l'esecuzione del test, è possibile utilizzare la macro `panic!` per segnalare un fallimento. In alternativa, è possibile utilizzare la macro `assert!` per verificare che una condizione sia vera, o la macro `assert_eq!` per verificare che due valori siano uguali.

## Esempio

Supponiamo di avere una funzione che calcola la somma di due numeri interi. Per assicurarci che questa funzione funzioni correttamente, possiamo scrivere un test unitario. Ecco un esempio di come potrebbe essere strutturato il codice:

```rust
// Funzione da testare
fn somma(a: i32, b: i32) -> i32 {
    a + b
}

// Modulo di test
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_somma() {
        assert_eq!(somma(2, 3), 5);
        assert_eq!(somma(-1, 1), 0);
        assert_eq!(somma(0, 0), 0);
    }
}
```

In questo esempio, la funzione `somma` è definita per calcolare la somma di due numeri interi. Il modulo `tests` contiene un test unitario chiamato `test_somma`, che utilizza la macro `assert_eq!` per verificare che la funzione `somma` restituisca i risultati attesi per diversi input.

## Pseudocodice

Ecco uno pseudocodice che illustra come scrivere test unitari in Rust:

```rust
// Definizione della funzione da testare
fn funzione_da_testare(input: Tipo) -> Tipo {
    // Logica della funzione
    risultato
}

// Modulo di test
#[cfg(test)]
mod tests {
    use super::*;

    // Test unitario
    #[test]
    fn nome_test() {
        // Setup del test
        let input = valore_input;
        let risultato_atteso = valore_atteso;

        // Esecuzione della funzione
        let risultato_ottenuto = funzione_da_testare(input);

        // Verifica del risultato
        assert_eq!(risultato_ottenuto, risultato_atteso);
    }
}
```

## Risorse

- [Documentazione ufficiale di Rust sui test](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)
- [Rust by Example: Testing](https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html)
- [Crates.io: librerie per il testing](https://crates.io/crates/test)

## Esercizio

Scrivi un test unitario per una funzione che calcola il prodotto di due numeri interi. Assicurati di testare diversi casi, inclusi numeri positivi, negativi e zero. Quali sono i passaggi principali che seguirai per scrivere questo test?