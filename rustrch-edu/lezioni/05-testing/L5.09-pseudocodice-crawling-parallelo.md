## Teoria

Il crawling parallelo è una tecnica essenziale per migliorare l'efficienza di un motore di ricerca, soprattutto quando si tratta di elaborare grandi quantità di dati. In Rust, la libreria Rayon offre un modo semplice ed efficiente per parallelizzare operazioni comuni, come l'elaborazione di collezioni di dati. Rayon è una libreria di parallelismo dati che consente di eseguire operazioni su collezioni in modo parallelo, sfruttando al meglio le risorse della CPU.

Rayon si basa sul concetto di "work-stealing", dove i thread che hanno completato i loro compiti possono "rubare" lavoro da altri thread che sono ancora occupati. Questo approccio garantisce un utilizzo equilibrato delle risorse e riduce i tempi di inattività dei thread. Inoltre, Rayon è progettato per essere sicuro e facile da usare, integrandosi perfettamente con il sistema di ownership e borrowing di Rust.

Uno dei principali vantaggi di Rayon è la sua semplicità. Con poche modifiche al codice, è possibile trasformare operazioni sequenziali in operazioni parallele. Ad esempio, invece di usare il metodo `iter()` per iterare su una collezione, si può usare `par_iter()` per eseguire l'iterazione in parallelo. Questo rende Rayon particolarmente adatto per task come il processing di dati, la ricerca e la manipolazione di collezioni.

## Esempio

Immaginiamo di avere un motore di ricerca che deve elaborare una grande quantità di documenti per costruire un indice invertito. Senza parallelismo, l'elaborazione di ogni documento avviene in modo sequenziale, il che può essere molto lento se il numero di documenti è elevato. Utilizzando Rayon, possiamo parallelizzare questo processo, dividendo il lavoro tra più thread.

Ad esempio, supponiamo di avere una lista di URL da cui scaricare i documenti e di voler elaborare ogni documento per estrarne i termini. Senza parallelismo, il codice potrebbe apparire così:

```rust
let urls = vec!["url1", "url2", "url3"];
let documents: Vec<_> = urls.iter()
    .map(|url| download_and_process(url))
    .collect();
```

Utilizzando Rayon, possiamo parallelizzare questa operazione:

```rust
use rayon::prelude::*;

let urls = vec!["url1", "url2", "url3"];
let documents: Vec<_> = urls.par_iter()
    .map(|url| download_and_process(url))
    .collect();
```

In questo esempio, `par_iter()` divide la lista di URL in più parti e elabora ogni parte in parallelo, riducendo significativamente il tempo totale di elaborazione.

## Pseudocodice

Ecco uno pseudocodice che illustra come utilizzare Rayon per parallelizzare il crawling di documenti in un motore di ricerca:

```rust
// Importa la libreria Rayon
use rayon::prelude::*;

// Funzione per scaricare e elaborare un singolo documento
fn download_and_process(url: &str) -> Document {
    // Scarica il documento dall'URL
    let content = download_url(url);
    
    // Elabora il documento e restituisci il risultato
    let mut document = Document::new();
    for term in content.split_whitespace() {
        *document.entry(term).or_insert(0) += 1;
    }
    document
}

// Funzione principale per elaborare tutti gli URL in parallelo
fn crawl_urls_parallel(urls: &[String]) -> Vec<Document> {
    // Utilizza par_iter() per elaborare gli URL in parallelo
    urls.par_iter()
        .map(|url| download_and_process(url))
        .collect()
}

// Esempio di utilizzo
fn main() {
    let urls = vec![
        "https://example.com/doc1".to_string(),
        "https://example.com/doc2".to_string(),
        "https://example.com/doc3".to_string(),
    ];
    
    let documents = crawl_urls_parallel(&urls);
    
    // Stampa i documenti elaborati
    for doc in documents {
        println!("{:?}", doc);
    }
}
```

## Risorse

- [Documentazione ufficiale di Rayon](https://docs.rs/rayon/latest/rayon/)
- [The Rust Book - Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Rayon GitHub Repository](https://github.com/rayon-rs/rayon)

## Esercizio

1. **Domanda**: Qual è il principale vantaggio dell'utilizzo di Rayon rispetto all'implementazione manuale del parallelismo in Rust?
   - **Traccia di soluzione**: Rayon offre un'interfaccia semplice e sicura per parallelizzare operazioni comuni, riducendo la complessità del codice e migliorando le prestazioni.

2. **Esercizio pratico**: Scrivi uno pseudocodice che utilizza Rayon per parallelizzare il crawling di una lista di URL e il calcolo della frequenza dei termini.
   - **Traccia di soluzione**: Utilizza `par_iter()` per iterare sulla lista di URL in parallelo, scaricare i documenti e calcolare la frequenza dei termini.

```rust
use rayon::prelude::*;

fn main() {
    let urls = vec![
        "https://example.com/doc1".to_string(),
        "https://example.com/doc2".to_string(),
        "https://example.com/doc3".to_string(),
    ];
    
    let term_frequencies: Vec<_> = urls.par_iter()
        .map(|url| {
            let content = download_url(url);
            let mut freq = HashMap::new();
            for term in content.split_whitespace() {
                *freq.entry(term).or_insert(0) += 1;
            }
            freq
        })
        .collect();
    
    println!("{:?}", term_frequencies);
}
```