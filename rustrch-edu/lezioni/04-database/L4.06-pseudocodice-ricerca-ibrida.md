## Teoria

La ricerca ibrida combina i vantaggi della ricerca tradizionale basata su parole chiave (come BM25) con la ricerca semantica basata su embedding. Questo approccio permette di ottenere risultati più accurati e pertinenti, poiché tiene conto sia della corrispondenza lessicale che del significato semantico dei documenti. La ricerca ibrida è particolarmente utile in contesti dove i documenti possono avere sinonimi, termini tecnici o concetti complessi che non sono facilmente catturabili con una semplice corrispondenza di parole chiave.

## Esempio

Immaginiamo di avere un motore di ricerca che deve trovare documenti relativi alla "programmazione funzionale in Rust". Una ricerca basata solo su BM25 potrebbe non catturare documenti che parlano di "programmazione funzionale" senza menzionare esplicitamente "Rust", o documenti che usano termini come "lambda" o "closure" invece di "programmazione funzionale". La ricerca semantica, d'altra parte, può catturare il significato sottostante dei documenti e trovare corrispondenze anche quando le parole chiave non sono presenti. Combinando entrambi i metodi, otteniamo risultati più completi e accurati.

## Pseudocodice

```rust
// Definizione delle strutture per i risultati di BM25 e embedding
struct BM25Result {
    doc_id: u32,
    score: f32,
}

struct EmbeddingResult {
    doc_id: u32,
    similarity: f32,
}

// Funzione per combinare i risultati di BM25 e embedding
fn combine_results(bm25_results: Vec<BM25Result>, embedding_results: Vec<EmbeddingResult>, alpha: f32) -> Vec<(u32, f32)> {
    // Crea una mappa per i punteggi BM25
    let mut bm25_scores: HashMap<u32, f32> = HashMap::new();
    for result in bm25_results {
        bm25_scores.insert(result.doc_id, result.score);
    }

    // Crea una mappa per i punteggi di similarità degli embedding
    let mut embedding_scores: HashMap<u32, f32> = HashMap::new();
    for result in embedding_results {
        embedding_scores.insert(result.doc_id, result.similarity);
    }

    // Combina i punteggi usando una media ponderata
    let mut combined_scores: Vec<(u32, f32)> = Vec::new();
    for (doc_id, bm25_score) in bm25_scores {
        let embedding_score = embedding_scores.get(&doc_id).unwrap_or(&0.0);
        let combined_score = alpha * bm25_score + (1.0 - alpha) * embedding_score;
        combined_scores.push((doc_id, combined_score));
    }

    // Ordina i risultati in base al punteggio combinato
    combined_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    combined_scores
}

// Funzione principale per la ricerca ibrida
fn hybrid_search(query: &str, alpha: f32) -> Vec<(u32, f32)> {
    // Esegui la ricerca BM25
    let bm25_results = bm25_search(query);

    // Esegui la ricerca semantica basata su embedding
    let embedding_results = embedding_search(query);

    // Combina i risultati
    combine_results(bm25_results, embedding_results, alpha)
}

// Funzione di esempio per la ricerca BM25
fn bm25_search(query: &str) -> Vec<BM25Result> {
    // Implementazione della ricerca BM25
    vec![]
}

// Funzione di esempio per la ricerca semantica
fn embedding_search(query: &str) -> Vec<EmbeddingResult> {
    // Implementazione della ricerca semantica
    vec![]
}
```

## Risorse

- [Rust Book: HashMap](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)
- [Rust by Example: Functions](https://doc.rust-lang.org/rust-by-example/fn.html)
- [Rust Standard Library: Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html)

## Esercizio

Implementa una funzione che combini i risultati di BM25 e embedding usando una media ponderata. Assicurati di gestire i casi in cui un documento non è presente in uno dei due risultati. Quali sono i vantaggi e gli svantaggi di questo approccio?