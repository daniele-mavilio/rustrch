## Teoria

L'algoritmo BM25 (Best Match 25) è uno dei metodi più utilizzati per il ranking dei documenti nei motori di ricerca. Si basa su una formula matematica che combina la frequenza dei termini (TF) e la frequenza inversa dei documenti (IDF) per determinare la rilevanza di un documento rispetto a una query di ricerca. La formula BM25 è stata sviluppata come miglioramento rispetto al tradizionale modello TF-IDF, introducendo parametri aggiuntivi che permettono di adattare il ranking a diverse tipologie di documenti e query.

La formula BM25 è definita come segue:

```
score(D, Q) = Σ (IDF(q_i) * (f(q_i, D) * (k1 + 1)) / (f(q_i, D) + k1 * (1 - b + b * (|D| / avgdl))))
```

Dove:
- `D` è il documento da valutare.
- `Q` è la query di ricerca.
- `q_i` è un termine della query.
- `f(q_i, D)` è la frequenza del termine `q_i` nel documento `D`.
- `|D|` è la lunghezza del documento `D`.
- `avgdl` è la lunghezza media dei documenti nell'indice.
- `k1` e `b` sono parametri di regolazione.

Il parametro `k1` controlla l'effetto della frequenza dei termini sulla rilevanza del documento. Un valore elevato di `k1` riduce l'impatto della frequenza dei termini, mentre un valore basso lo aumenta. Il parametro `b` controlla l'effetto della lunghezza del documento sulla rilevanza. Un valore di `b` pari a 1 significa che la lunghezza del documento ha un impatto completo, mentre un valore di 0 significa che non ha alcun impatto.

## Esempio

Supponiamo di avere un insieme di documenti e una query di ricerca. Vogliamo calcolare il punteggio BM25 per ogni documento rispetto alla query. Ad esempio, consideriamo i seguenti documenti:

- Documento 1: "Il gatto nero è seduto sul tappeto."
- Documento 2: "Il cane marrone sta correndo nel parco."
- Documento 3: "Il gatto marrone è seduto sul divano."

E la query di ricerca: "gatto marrone".

Per calcolare il punteggio BM25 per ogni documento, dobbiamo prima calcolare l'IDF per ogni termine della query. L'IDF è una misura di quanto un termine è raro nell'insieme dei documenti. Più un termine è raro, più è importante per determinare la rilevanza di un documento.

Successivamente, calcoliamo la frequenza dei termini nei documenti e applichiamo la formula BM25 per ottenere il punteggio di rilevanza per ogni documento.

## Pseudocodice

```rust
// Definizione della struttura per un documento
struct Document {
    id: u32,
    content: String,
    length: usize,
}

// Funzione per calcolare l'IDF di un termine
fn calculate_idf(term: &str, documents: &[Document], total_documents: usize) -> f64 {
    let mut doc_count = 0;
    for doc in documents {
        if doc.content.contains(term) {
            doc_count += 1;
        }
    }
    let idf = (total_documents - doc_count + 0.5) / (doc_count + 0.5) + 1.0;
    idf.ln()
}

// Funzione per calcolare il punteggio BM25
fn calculate_bm25_score(
    document: &Document,
    query_terms: &[&str],
    idf_values: &[f64],
    k1: f64,
    b: f64,
    avg_doc_length: f64,
) -> f64 {
    let mut score = 0.0;
    for (i, &term) in query_terms.iter().enumerate() {
        let term_freq = document.content.matches(term).count() as f64;
        let numerator = term_freq * (k1 + 1.0);
        let denominator = term_freq + k1 * (1.0 - b + b * (document.length as f64 / avg_doc_length));
        score += idf_values[i] * (numerator / denominator);
    }
    score
}

// Esempio di utilizzo
fn main() {
    let documents = vec![
        Document {
            id: 1,
            content: "Il gatto nero è seduto sul tappeto.".to_string(),
            length: 35,
        },
        Document {
            id: 2,
            content: "Il cane marrone sta correndo nel parco.".to_string(),
            length: 38,
        },
        Document {
            id: 3,
            content: "Il gatto marrone è seduto sul divano.".to_string(),
            length: 36,
        },
    ];

    let query_terms = vec!["gatto", "marrone"];
    let total_documents = documents.len();
    let avg_doc_length = documents.iter().map(|d| d.length).sum::<usize>() as f64 / total_documents as f64;

    let idf_values: Vec<f64> = query_terms
        .iter()
        .map(|&term| calculate_idf(term, &documents, total_documents))
        .collect();

    let k1 = 1.5;
    let b = 0.75;

    for doc in &documents {
        let score = calculate_bm25_score(doc, &query_terms, &idf_values, k1, b, avg_doc_length);
        println!("Document {} score: {}", doc.id, score);
    }
}
```

## Risorse

- [Documentazione ufficiale di BM25](https://en.wikipedia.org/wiki/Okapi_BM25)
- [Guida pratica all'implementazione di BM25](https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html)
- [Libreria Rust per BM25](https://crates.io/crates/bm25)

## Esercizio

Implementa una funzione in Rust che calcoli il punteggio BM25 per un insieme di documenti e una query di ricerca. Utilizza le strutture e le funzioni definite nel pseudocodice come punto di partenza. Assicurati di gestire correttamente i casi in cui un termine della query non è presente in alcun documento.