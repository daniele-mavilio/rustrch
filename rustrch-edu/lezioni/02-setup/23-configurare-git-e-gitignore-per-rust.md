# Configurare Git e .gitignore per Rust

## Teoria

Git è il sistema di versionamento distribuito più utilizzato al mondo, essenziale per qualsiasi progetto software. Per progetti Rust, configurare correttamente Git significa non solo tracciare il codice sorgente, ma anche escludere appropriatamente file generati automaticamente come binari compilati, dipendenze scaricate, e file temporanei. Un file `.gitignore` ben configurato mantiene il repository pulito e riduce la dimensione.

Il file `.gitignore` specifica pattern di file e directory che Git dovrebbe ignorare. Per Rust, le esclusioni essenziali includono: la directory `target/` (contiene artefatti di compilazione), `Cargo.lock` per le librerie (ma non per i binari), file eseguibili, e file temporanei dell'IDE. Rust stesso fornisce un template `.gitignore` ottimizzato attraverso GitHub o strumenti come `gitignore.io`.

Oltre al `.gitignore` base, è buona pratica configurare attributi Git per trattare correttamente file specifici: file binari che non dovrebbero essere diffati, file di lock che dovrebbero essere trattati come testo, e configurazioni di merge per file specifici. Questo migliora l'esperienza di sviluppo e previene problemi comuni.

## Esempio

File `.gitignore` base per Rust:

```gitignore
# Generated by Cargo
/target/
**/*.rs.bk

# Remove Cargo.lock from gitignore if creating an executable
# Cargo.lock

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
```

Differenza tra libreria e binario:
- **Libreria**: escludi `Cargo.lock` (dipendenze gestite dal consumer)
- **Binario**: includi `Cargo.lock` (versioni deterministiche per deploy)

## Pseudocodice

```bash
// GITIGNORE BASE PER RUST

// File: .gitignore
// Generated by Cargo
// will have compiled files and executables
debug/
target/

// Remove Cargo.lock from gitignore if creating an executable
// leave it for libraries
// More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

// These are backup files generated by rustfmt
**/*.rs.bk

// MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

// IDE
.idea/
.vscode/
*.swp
*.swo
*~
.vs/

// OS
.DS_Store
Thumbs.db

// Logs
*.log

// Environment
.env
.env.local

// GITIGNORE PER BINARI (APPLICAZIONI)

// Per applicazioni, INCLUDI Cargo.lock
// Non escluderlo nel .gitignore

// File: .gitignore
/target/
**/*.rs.bk
*.pdb

// IDE
.idea/
.vscode/
*.swp

// OS
.DS_Store

// ENV
.env

// GITIGNORE ESTESO

// File: .gitignore

// === RUST ===
# Compiled files
/target/
/debug/
/release/

# Lock file (per librerie)
Cargo.lock

# Backup rustfmt
**/*.rs.bk

# Profiling
*.profdata
*.profraw

# Coverage
cobertura.xml
tarpaulin-report.html
*.lcov

// === IDE ===
# IntelliJ
.idea/
*.iml
*.ipr
*.iws
out/

# VS Code
.vscode/
*.code-workspace
.history/

# Vim
*.swp
*.swo
*~
.netrwhist

# Emacs
*~
\#*\#
.\#*

# Sublime
*.sublime-project
*.sublime-workspace

// === OS ===
# macOS
.DS_Store
.AppleDouble
.LSOverride
._*

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.stackdump
[Dd]esktop.ini
$RECYCLE.BIN/

# Linux
*~
.nfs*
.directory
.Trash-*

// === STRUMENTI ===
# Coverage
coverage/
*.lcov
.nyc_output

# Benchmark
criterion/

# Documentation generated
doc/

// === PROGETTO SPECIFICO ===
# Configurazione locale
config.local.toml

# Database
*.db
*.sqlite
*.sqlite3

# Logs
logs/
*.log
npm-debug.log*

# Runtime
pids/
*.pid
*.seed
*.pid.lock

// GIT ATTRIBUTES

// File: .gitattributes

// Treat all files in the repo as UTF-8 by default
* text=auto

// Rust source files
*.rs text eol=lf
*.toml text eol=lf

// Shell scripts should always use LF
*.sh text eol=lf

// Windows scripts use CRLF
*.bat text eol=crlf
*.cmd text eol=crlf

// Binary files
*.png binary
*.jpg binary
*.gif binary
*.ico binary
*.pdf binary

// Lock files
crates.lock binary
yarn.lock binary
package-lock.json binary

// Large files with LFS
*.psd filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text

// WORKFLOW GIT BASE

// Inizializza repository
$ git init

// Aggiungi .gitignore
$ curl -o .gitignore https://raw.githubusercontent.com/github/gitignore/main/Rust.gitignore

// Per binari, modifica per non ignorare Cargo.lock
$ sed -i '/Cargo.lock/d' .gitignore

// Primo commit
$ git add .
$ git commit -m "Initial commit"

// Branch principale
$ git branch -M main

// Aggiungi remote
$ git remote add origin https://github.com/username/repo.git
$ git push -u origin main

// COMANDI GIT UTILI

// Stato
$ git status

// Aggiungi file
$ git add file.rs
$ git add .                    // Tutti i file modificati

// Commit
$ git commit -m "Messaggio"
$ git commit -am "Messaggio"   // Add + commit

// Log
$ git log --oneline
$ git log --graph --oneline --all

// Branch
$ git branch nome-branch
$ git checkout -b nome-branch  // Crea e switcha
$ git switch -c nome-branch    // Nuova sintassi

// Merge
$ git checkout main
$ git merge feature-branch

// Pull/Push
$ git pull origin main
$ git push origin main

// Stash
$ git stash
$ git stash pop

// Reset
$ git reset --soft HEAD~1      // Toglie ultimo commit, mantiene modifiche
$ git reset --hard HEAD~1      // Toglie commit e modifiche

// TAG
$ git tag -a v1.0.0 -m "Version 1.0.0"
$ git push origin v1.0.0
$ git push origin --tags

// RIMOZIONE FILE GIA' COMMITTATI

// Se hai accidentalmente committato target/
$ git rm -r --cached target/
$ echo "target/" >> .gitignore
$ git add .gitignore
$ git commit -m "Remove target/ from git"

// Se hai committato Cargo.lock per una libreria
$ git rm --cached Cargo.lock
$ echo "Cargo.lock" >> .gitignore
$ git add .gitignore
$ git commit -m "Remove Cargo.lock"

// HOOKS GIT

// File: .git/hooks/pre-commit
#!/bin/bash
set -e

echo "Running cargo fmt..."
cargo fmt --all -- --check

echo "Running cargo clippy..."
cargo clippy --all-targets --all-features -- -D warnings

echo "Running tests..."
cargo test

echo "Pre-commit checks passed!"

// Rendi eseguibile:
$ chmod +x .git/hooks/pre-commit

// CONVENZIONI COMMIT

// feat: nuova feature
// fix: bug fix
// docs: documentazione
// style: formattazione
// refactor: refactoring
// test: test
// chore: manutenzione

// Esempi:
// feat: add user authentication
// fix: resolve memory leak in parser
// docs: update API documentation

// TEMPLATE COMMIT

// .gitmessage
// <type>: <subject>
//
// <body>
//
// <footer>

// Configura:
$ git config commit.template .gitmessage
```

## Risorse

- [Git Handbook](https://guides.github.com/introduction/git-handbook/)
[Gitignore Templates](https://github.com/github/gitignore)
- [Git Attributes](https://git-scm.com/docs/gitattributes)

## Esercizio

Configura Git per un progetto Rust:

1. Crea un progetto "git-demo"
2. Inizializza repository Git
3. Aggiungi `.gitignore` appropriato per un'applicazione
4. Fai il primo commit
5. Crea un file `src/config.rs`, aggiungi e committa
6. Modifica il file e verifica `git status`
7. Crea un branch `feature`, fai una modifica e committa
8. Torna su `main` e fai merge

**Traccia di soluzione:**
```bash
# 1. Crea progetto
cargo new git-demo --bincd git-demo

# 2. Inizializza Git
git init

# 3. Crea .gitignore (per binario, NON escludere Cargo.lock)
cat > .gitignore << 'EOF'
/target/
**/*.rs.bk
*.pdb
.idea/
.vscode/
*.swp
.DS_Store
.env
EOF

# 4. Primo commit
git add .
git commit -m "Initial commit"

# 5. Crea config.rs
touch src/config.rs
git add src/config.rs
git commit -m "feat: add config module"

# 6. Modifica e verifica
echo "// Config" >> src/config.rs
git status  # Mostra modified

# 7. Crea branch
git checkout -b feature
echo "// New feature" >> src/config.rs
git add .
git commit -m "feat: add new feature"

# 8. Merge
git checkout main
git merge feature
```
