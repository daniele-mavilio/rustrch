## Teoria

In Rust, la programmazione asincrona permette di scrivere codice non bloccante, essenziale per applicazioni ad alta concorrenza come server web o motori di ricerca. Un future rappresenta una computazione asincrona che potrebbe non essere completata immediatamente. Il concetto chiave è che un future non blocca il thread corrente; invece, restituisce un valore futuro. L'operatore `async` marca una funzione come asincrona, mentre `await` sospende l'esecuzione fino al completamento del future. Questo approccio impedisce blocchi thread, migliorando scalability. Ad esempio, le leggi che legano i future sono: un future è "lazy" (non eseguito finché non "polled"), singola esecuzione (once polled, non ricomincia), e richiede un runtime come Tokio per polling. Con `async/await`, il codice appare sincrono ma è asincrono sotto il cofano. Questa astrazione semplifica errori comuni nel codice concorrente, come deadlock. Pertanto, garantisce efficienza senza sacrificare leggibilità. (180 parole)

## Esempio

Immagina di costruire un crawler web per raccogliere dati. Una richiesta HTTP sincrona blocca il thread principale, rendendo appenschibile l'app con molteplici link. Invece, usa `async/await`: scrivi una funzione `async fn fetch(url: &str) -> Result<String, Error>` che invia request e attende risposta. Nel codice principale, chiama `let content = fetch(url).await?;` per non bloccare. Questo permette di gestire migliaia di fetch contemporaneamente su un ristretto numero di thread. In un motore di ricerca, fonde url dai risultati di ricerca, crawl in parallelo senza bloccare l'interfaccia utente. L'esempio mostra come `async/await` renda il crawling scalabile e responsivo, essenziale per grandi dataset. (120 parole)

## Pseudocodice

```rust
// Il cuore dell'asincronia è il futuro, che rappresenta un computazione che potrebbe non essere pronta subito
// Un future porta implementare il trait Future, con un metodo poll che verifica se il risultato è disponibile

// Per definire una funzione asincrona, usa la parola chiave async
// Questo trasforma la funzione in un futuro che, quando chiamato, non blocca il thread ma restituisce immediatamente un futuro

// Dentro la funzione asincrona, usa await per sospendere l'esecuzione su operazioni asincrone
// Await preleva il future e cede controllo al runtime se necessario
// Esempio colloquiale: immagina di ordinare cibo – async è chiudere l'ordine, await è aspettare la consegna

// Il runtime asincrono (come Tokio) gestisce il polling dei futuri
// Polling significa controllare se il future è pronto; se sì, continua; se no, schedula per dopo

// Importante: futures sono lazy – non fanno nulla finché non polled
// Quindi, chiamare una funzione async non esegue il codice dentro – solo crea il futuro

// Per eseguire, aspetta il futuro con await o usa strumenti come join/data per combinazione

// Concetto chiave: modesti thread per bisogni concurrency elevati
// Invece di un thread per request, usa await per multiplexare
```

## Risorse

- https://doc.rust-lang.org/book/ch16-01-threads.html
- https://docs.rs/tokio/latest/tokio/
- https://doc.rust-lang.org/rust-by-example/std_misc/async.html
- https://crates.io/crates/reqwest

## Esercizio

Scrivi una funzione asincrona che accetta un vettore di URL e restituisce un vettore di futuri per fetch concorrente. Considera timeout per evitare blocchi infiniti. (Traccia: Usa `tokio::time::timeout` e `futures::future::join_all` per combinare futuri.)